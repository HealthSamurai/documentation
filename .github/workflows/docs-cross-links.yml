name: Documentation Cross-Links

on:
  push:
    branches: [master]
    paths:
      - 'docs/**/*.md'
      - '!docs/reference/**'
      - '!docs/deprecated/**'
  workflow_dispatch:
    inputs:
      test_commit:
        description: 'Test on specific commit SHA (e.g., 84d62e02)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  cross-links:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get changed files
      id: changes
      run: |
        if [ -n "${{ inputs.test_commit }}" ]; then
          COMMIT="${{ inputs.test_commit }}"
          echo "Testing on commit: $COMMIT"
          CHANGED=$(git diff --name-only --diff-filter=AM ${COMMIT}~1 ${COMMIT} -- 'docs/**/*.md' | grep -v 'docs/reference/' | grep -v 'docs/deprecated/' | grep -v 'assets/' | grep -v 'images/' | head -5)
        else
          CHANGED=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD -- 'docs/**/*.md' | grep -v 'docs/reference/' | grep -v 'docs/deprecated/' | grep -v 'assets/' | grep -v 'images/' | head -5)
        fi
        if [ -z "$CHANGED" ]; then
          echo "No relevant changes"
          echo "has_changes=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        echo "Changed files:"
        echo "$CHANGED"
        echo "has_changes=true" >> $GITHUB_OUTPUT
        echo "$CHANGED" > /tmp/changed_files.txt

    - name: "Step 1: Find related files"
      if: steps.changes.outputs.has_changes == 'true'
      id: find_files
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        # Collect changed files info
        echo "=== Changed/new documentation files ===" > /tmp/changed_info.txt
        while read -r file; do
          if [ -f "$file" ]; then
            echo "" >> /tmp/changed_info.txt
            echo "FILE: $file" >> /tmp/changed_info.txt
            TITLE=$(grep -m1 '^#' "$file" | sed 's/^#* //')
            echo "TITLE: $TITLE" >> /tmp/changed_info.txt
            echo "FIRST 50 LINES:" >> /tmp/changed_info.txt
            head -50 "$file" >> /tmp/changed_info.txt
          fi
        done < /tmp/changed_files.txt

        # Find parent READMEs
        PARENT_READMES=""
        while read -r file; do
          DIR=$(dirname "$file")
          if [ -f "$DIR/README.md" ]; then
            PARENT_READMES="$PARENT_READMES $DIR/README.md"
          fi
        done < /tmp/changed_files.txt

        # Build prompt
        {
          echo "You are a documentation cross-linking assistant. Identify which EXISTING files should link to the changed files."
          echo ""
          echo "PRIORITY (in order):"
          echo "1. Direct parent README.md in the same directory"
          echo "2. Overview/concept pages in the SAME section (e.g., if new file is in tutorials/artifact-registry-tutorials/, look for docs/artifact-registry/artifact-registry-overview.md)"
          echo "3. Related feature pages in the same subsection"
          echo ""
          echo "DO NOT include:"
          echo "- General index pages (docs/README.md, docs/tutorials/README.md)"
          echo "- Files from completely different sections"
          echo "- Files already listed in Parent READMEs"
          echo ""
          echo "Return max 3 files. Return JSON: {\"files_to_check\": [\"docs/path/file.md\"], \"reasoning\": \"explanation\"}"
        } > /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Changed files ===" >> /tmp/prompt1.txt
        cat /tmp/changed_info.txt >> /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Parent READMEs (high priority) ===" >> /tmp/prompt1.txt
        echo "$PARENT_READMES" >> /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Documentation structure ===" >> /tmp/prompt1.txt
        grep -v '/deprecated/' docs/SUMMARY.md | head -300 >> /tmp/prompt1.txt

        # Debug: show prompt size
        echo "Prompt size: $(wc -c < /tmp/prompt1.txt) bytes"

        # Build JSON payload first
        echo "Building JSON payload..."
        if ! jq -n --rawfile prompt /tmp/prompt1.txt '{contents: [{parts: [{text: $prompt}]}], generationConfig: {responseMimeType: "application/json"}}' > /tmp/payload1.json 2>&1; then
          echo "jq failed to build payload:"
          cat /tmp/payload1.json
          exit 1
        fi
        echo "Payload size: $(wc -c < /tmp/payload1.json) bytes"

        # Call Gemini
        echo "Calling Gemini (Step 1)..."

        # Trim API key (remove any whitespace/newlines)
        API_KEY=$(echo "$GEMINI_API_KEY" | tr -d '[:space:]')
        echo "API key length after trim: ${#API_KEY}"

        # Make request
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/gemini_response.json \
          -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}" \
          -H "Content-Type: application/json" \
          -d @/tmp/payload1.json)

        echo "HTTP status: $HTTP_CODE"

        if [ "$HTTP_CODE" != "200" ]; then
          echo "Gemini API error:"
          cat /tmp/gemini_response.json
          exit 1
        fi

        RESPONSE=$(cat /tmp/gemini_response.json)
        RESULT=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(d.get('candidates',[{}])[0].get('content',{}).get('parts',[{}])[0].get('text',''))" 2>/dev/null)

        if [ -z "$RESULT" ] || [ "$RESULT" = "null" ]; then
          echo "Error parsing Gemini response:"
          cat /tmp/gemini_response.json | head -50
          exit 1
        fi

        echo "Step 1 result: $RESULT"
        FILES_TO_CHECK=$(echo "$RESULT" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print('\n'.join(d.get('files_to_check',[])[:5]))" 2>/dev/null)

        if [ -z "$FILES_TO_CHECK" ]; then
          echo "No files to check"
          echo "has_files=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "$FILES_TO_CHECK" > /tmp/files_to_check.txt
        echo "Files to check:"
        cat /tmp/files_to_check.txt
        echo "has_files=true" >> $GITHUB_OUTPUT

    - name: "Step 2: Generate suggestions"
      if: steps.find_files.outputs.has_files == 'true'
      id: suggestions
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        # Read target files
        echo "=== Target files ===" > /tmp/targets_content.txt
        while read -r file; do
          [[ ! "$file" =~ ^docs/ ]] && file="docs/$file"
          if [ -f "$file" ]; then
            echo "" >> /tmp/targets_content.txt
            echo "TARGET FILE: $file" >> /tmp/targets_content.txt
            echo "CONTENT (with line numbers):" >> /tmp/targets_content.txt
            head -500 "$file" | nl -ba >> /tmp/targets_content.txt
            echo "---END---" >> /tmp/targets_content.txt
          fi
        done < /tmp/files_to_check.txt

        # Build prompt
        {
          echo "You are a documentation editor. Add MINIMAL cross-reference links to new documentation."
          echo ""
          echo "STRICT RULES:"
          echo "1. Add ONLY a link to the new file - do NOT rewrite sections, add descriptions, or create indexes"
          echo "2. Find existing bullet lists or \"See also\" sections and add ONE line with a link"
          echo "3. If no list exists, create a minimal \"See also:\" section at the end"
          echo "4. Use operation \"replace\" to add to existing lists, \"append\" only for new sections"
          echo "5. DO NOT duplicate content or create summaries"
          echo ""
          echo "EXAMPLES OF GOOD suggestions:"
          echo "{\"operation\": \"replace\", \"find\": \"- [Existing link](path.md)\", \"replace\": \"- [Existing link](path.md)\\n- [New tutorial](new-path.md)\", \"reason\": \"Add link to existing list\"}"
          echo "{\"operation\": \"append\", \"find\": \"\", \"replace\": \"\\nSee also:\\n- [New tutorial](path.md)\", \"reason\": \"No existing links section\"}"
          echo ""
          echo "EXAMPLES OF BAD suggestions (DO NOT DO THIS):"
          echo "- Creating large content blocks or indexes"
          echo "- Rewriting entire sections"
          echo "- Adding descriptions or summaries"
          echo "- Modifying unrelated text"
          echo ""
          echo "Return JSON: {\"suggestions\": [{\"target_file\": \"path\", \"operation\": \"replace or append\", \"line_number\": N, \"find\": \"exact text to find\", \"replace\": \"new text\", \"reason\": \"why\"}]}"
        } > /tmp/prompt2.txt
        echo "" >> /tmp/prompt2.txt
        echo "=== NEW FILES ===" >> /tmp/prompt2.txt
        cat /tmp/changed_info.txt >> /tmp/prompt2.txt
        cat /tmp/targets_content.txt >> /tmp/prompt2.txt

        # Debug: show prompt size
        echo "Prompt size: $(wc -c < /tmp/prompt2.txt) bytes"

        # Build JSON payload first
        echo "Building JSON payload..."
        if ! jq -n --rawfile prompt /tmp/prompt2.txt '{contents: [{parts: [{text: $prompt}]}], generationConfig: {responseMimeType: "application/json"}}' > /tmp/payload2.json 2>&1; then
          echo "jq failed to build payload:"
          cat /tmp/payload2.json
          exit 1
        fi
        echo "Payload size: $(wc -c < /tmp/payload2.json) bytes"

        # Call Gemini
        echo "Calling Gemini (Step 2)..."
        API_KEY=$(echo "$GEMINI_API_KEY" | tr -d '[:space:]')

        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/gemini_response2.json \
          -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}" \
          -H "Content-Type: application/json" \
          -d @/tmp/payload2.json)

        echo "HTTP status: $HTTP_CODE"

        if [ "$HTTP_CODE" != "200" ]; then
          echo "Gemini API error:"
          cat /tmp/gemini_response2.json
          exit 1
        fi

        RESPONSE=$(cat /tmp/gemini_response2.json)
        SUGGESTIONS=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(d.get('candidates',[{}])[0].get('content',{}).get('parts',[{}])[0].get('text',''))" 2>/dev/null)

        if [ -z "$SUGGESTIONS" ] || [ "$SUGGESTIONS" = "null" ]; then
          echo "Error parsing Gemini response:"
          cat /tmp/gemini_response2.json | head -50
          exit 1
        fi

        echo "Step 2 result: $SUGGESTIONS"
        echo "$SUGGESTIONS" > /tmp/suggestions.json

        COUNT=$(echo "$SUGGESTIONS" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(len(d.get('suggestions',[])))" 2>/dev/null || echo "0")
        if [ "$COUNT" = "0" ]; then
          echo "No suggestions"
          echo "has_suggestions=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "has_suggestions=true" >> $GITHUB_OUTPUT
        echo "Found $COUNT suggestions"

    - name: Apply suggestions
      if: steps.suggestions.outputs.has_suggestions == 'true'
      id: apply
      run: |
        # Write apply script
        base64 -d > /tmp/apply.py << 'B64'
        aW1wb3J0IGpzb24sIHJlLCBvcwp3aXRoIG9wZW4oJy90bXAvc3VnZ2VzdGlvbnMuanNvbicsICdyJykgYXMgZjoKICAgIGRhdGEgPSBqc29uLmxvYWRzKGYucmVhZCgpLCBzdHJpY3Q9RmFsc2UpCnN1Z2dlc3Rpb25zID0gZGF0YS5nZXQoJ3N1Z2dlc3Rpb25zJywgW10pCmlmIG5vdCBzdWdnZXN0aW9uczoKICAgIHByaW50KCdObyBzdWdnZXN0aW9ucycpCiAgICBleGl0KDApCnByaW50KGYnQXBwbHlpbmcge2xlbihzdWdnZXN0aW9ucyl9IHN1Z2dlc3Rpb25zLi4uJykKZGVmIG5vcm1hbGl6ZShzKToKICAgIHJldHVybiByZS5zdWIocidccysnLCAnICcsIHMuc3RyaXAoKSkKZm9yIHMgaW4gc3VnZ2VzdGlvbnM6CiAgICB0YXJnZXQgPSBzLmdldCgndGFyZ2V0X2ZpbGUnLCAnJykKICAgIG9wID0gcy5nZXQoJ29wZXJhdGlvbicsICcnKQogICAgZmluZCA9IHMuZ2V0KCdmaW5kJywgJycpCiAgICByZXBsYWNlID0gcy5nZXQoJ3JlcGxhY2UnLCAnJykKICAgIGxuID0gcy5nZXQoJ2xpbmVfbnVtYmVyJykKICAgIHByaW50KGYnLS0tIHt0YXJnZXR9ICh7b3B9KScpCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHModGFyZ2V0KToKICAgICAgICBwcmludCgnU0tJUDogbm90IGZvdW5kJykKICAgICAgICBjb250aW51ZQogICAgbGlua3MgPSByZS5maW5kYWxsKHInXF1cKChbXildK1wubWQpXCknLCByZXBsYWNlKQogICAgd2l0aCBvcGVuKHRhcmdldCwgJ3InKSBhcyBmOgogICAgICAgIGNvbnRlbnQgPSBmLnJlYWQoKQogICAgaWYgYW55KGwgaW4gY29udGVudCBmb3IgbCBpbiBsaW5rcyk6CiAgICAgICAgcHJpbnQoJ1NLSVA6IGxpbmsgZXhpc3RzJykKICAgICAgICBjb250aW51ZQogICAgaWYgb3AgPT0gJ2FwcGVuZCc6CiAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ2EnKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKHJlcGxhY2UgKyAnXG4nKQogICAgICAgIHByaW50KCdET05FOiBhcHBlbmRlZCcpCiAgICBlbGlmIG9wID09ICdyZXBsYWNlJzoKICAgICAgICBpZiBmaW5kIGFuZCBmaW5kIGluIGNvbnRlbnQ6CiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoZmluZCwgcmVwbGFjZSwgMSkKICAgICAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ3cnKSBhcyBmOgogICAgICAgICAgICAgICAgZi53cml0ZShjb250ZW50KQogICAgICAgICAgICBwcmludCgnRE9ORTogZXhhY3QgbWF0Y2gnKQogICAgICAgIGVsaWYgZmluZDoKICAgICAgICAgICAgbm9ybSA9IG5vcm1hbGl6ZShmaW5kKQogICAgICAgICAgICBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xuJykKICAgICAgICAgICAgZG9uZSA9IEZhbHNlCiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihsaW5lcykpOgogICAgICAgICAgICAgICAgZm9yIHcgaW4gcmFuZ2UoMSwgbWluKDYsIGxlbihsaW5lcyktaSsxKSk6CiAgICAgICAgICAgICAgICAgICAgaWYgbm9ybWFsaXplKCdcbicuam9pbihsaW5lc1tpOmkrd10pKSA9PSBub3JtOgogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4odGFyZ2V0LCAndycpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCdcbicuam9pbihsaW5lc1s6aV0gKyBbcmVwbGFjZV0gKyBsaW5lc1tpK3c6XSkpCiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50KGYnRE9ORTogZnV6enkgYXQgbGluZSB7aSsxfScpCiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBUcnVlCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBpZiBkb25lOgogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGlmIGRvbmU6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgIGlmIGxuOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZHggPSBpbnQobG4pIC0gMQogICAgICAgICAgICAgICAgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcbicpCiAgICAgICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihsaW5lcyk6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ3cnKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCdcbicuam9pbihsaW5lc1s6aWR4KzFdICsgW3JlcGxhY2VdICsgbGluZXNbaWR4KzE6XSkpCiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZidET05FOiBsaW5lIHtsbn0gZmFsbGJhY2snKQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICBwcmludCgnU0tJUDogbm90IGZvdW5kJyk=
        B64
        python3 /tmp/apply.py
        if git diff --quiet docs/; then
          echo "No changes made"
          echo "applied=false" >> $GITHUB_OUTPUT
        else
          echo "Changes applied"
          echo "applied=true" >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      if: steps.apply.outputs.applied == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        BRANCH="auto/cross-links-$(date +%Y%m%d-%H%M%S)"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git checkout -b "$BRANCH"
        git add docs/
        git commit -m "docs: add cross-links to related documentation"
        git push origin "$BRANCH"
        gh pr create --title "docs: add cross-links for recent changes" --body "Auto-generated cross-links. Please review." --head "$BRANCH" --base master
