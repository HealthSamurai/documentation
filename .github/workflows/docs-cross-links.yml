name: Documentation Cross-Links

on:
  push:
    branches: [master]
    paths:
      - 'docs/**/*.md'
      - '!docs/reference/**'
      - '!docs/deprecated/**'
  workflow_dispatch:
    inputs:
      test_commit:
        description: 'Test on specific commit SHA (e.g., 84d62e02)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  cross-links:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get changed files
      id: changes
      run: |
        if [ -n "${{ inputs.test_commit }}" ]; then
          COMMIT="${{ inputs.test_commit }}"
          echo "Testing on commit: $COMMIT"
          CHANGED=$(git diff --name-only --diff-filter=AM ${COMMIT}~1 ${COMMIT} -- 'docs/**/*.md' | grep -v 'docs/reference/' | grep -v 'docs/deprecated/' | grep -v 'assets/' | grep -v 'images/' | head -5)
        else
          CHANGED=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD -- 'docs/**/*.md' | grep -v 'docs/reference/' | grep -v 'docs/deprecated/' | grep -v 'assets/' | grep -v 'images/' | head -5)
        fi
        if [ -z "$CHANGED" ]; then
          echo "No relevant changes"
          echo "has_changes=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        echo "Changed files:"
        echo "$CHANGED"
        echo "has_changes=true" >> $GITHUB_OUTPUT
        echo "$CHANGED" > /tmp/changed_files.txt

    - name: "Step 1: Find related files"
      if: steps.changes.outputs.has_changes == 'true'
      id: find_files
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        # Collect changed files info
        echo "=== Changed/new documentation files ===" > /tmp/changed_info.txt
        while read -r file; do
          if [ -f "$file" ]; then
            echo "" >> /tmp/changed_info.txt
            echo "FILE: $file" >> /tmp/changed_info.txt
            TITLE=$(grep -m1 '^#' "$file" | sed 's/^#* //')
            echo "TITLE: $TITLE" >> /tmp/changed_info.txt
            echo "FIRST 50 LINES:" >> /tmp/changed_info.txt
            head -50 "$file" >> /tmp/changed_info.txt
          fi
        done < /tmp/changed_files.txt

        # Find parent READMEs
        PARENT_READMES=""
        while read -r file; do
          DIR=$(dirname "$file")
          if [ -f "$DIR/README.md" ]; then
            PARENT_READMES="$PARENT_READMES $DIR/README.md"
          fi
        done < /tmp/changed_files.txt

        # Build prompt
        echo 'You are a documentation cross-linking assistant. Identify which EXISTING files should link to the changed files. Think about: Parent README files (MOST IMPORTANT), concept/overview pages, related features. Rules: Return max 5 files, ignore docs/reference/ and docs/deprecated/, files must be different from changed files. Return JSON: {"files_to_check": ["docs/path/file.md"], "reasoning": "explanation"}' > /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Changed files ===" >> /tmp/prompt1.txt
        cat /tmp/changed_info.txt >> /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Parent READMEs (high priority) ===" >> /tmp/prompt1.txt
        echo "$PARENT_READMES" >> /tmp/prompt1.txt
        echo "" >> /tmp/prompt1.txt
        echo "=== Documentation structure ===" >> /tmp/prompt1.txt
        grep -v '/deprecated/' docs/SUMMARY.md | head -300 >> /tmp/prompt1.txt

        # Debug: show prompt size
        echo "Prompt size: $(wc -c < /tmp/prompt1.txt) bytes"

        # Build JSON payload first
        echo "Building JSON payload..."
        if ! jq -n --rawfile prompt /tmp/prompt1.txt '{contents: [{parts: [{text: $prompt}]}], generationConfig: {responseMimeType: "application/json"}}' > /tmp/payload1.json 2>&1; then
          echo "jq failed to build payload:"
          cat /tmp/payload1.json
          exit 1
        fi
        echo "Payload size: $(wc -c < /tmp/payload1.json) bytes"

        # Call Gemini
        echo "Calling Gemini (Step 1)..."
        echo "API key length: ${#GEMINI_API_KEY}"
        API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}"
        echo "URL length: ${#API_URL}"

        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/gemini_response.json -X POST "$API_URL" -H "Content-Type: application/json" --data-binary @/tmp/payload1.json 2>&1 || echo "curl_failed")

        if [ "$HTTP_CODE" = "curl_failed" ]; then
          echo "curl command failed"
          echo "Trying with verbose..."
          curl -v -X POST "$API_URL" -H "Content-Type: application/json" --data-binary @/tmp/payload1.json 2>&1 | head -50
          exit 1
        fi

        echo "HTTP status: $HTTP_CODE"

        if [ "$HTTP_CODE" != "200" ]; then
          echo "Gemini API error:"
          cat /tmp/gemini_response.json
          exit 1
        fi

        RESPONSE=$(cat /tmp/gemini_response.json)
        RESULT=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(d.get('candidates',[{}])[0].get('content',{}).get('parts',[{}])[0].get('text',''))" 2>/dev/null)

        if [ -z "$RESULT" ] || [ "$RESULT" = "null" ]; then
          echo "Error parsing Gemini response:"
          cat /tmp/gemini_response.json | head -50
          exit 1
        fi

        echo "Step 1 result: $RESULT"
        FILES_TO_CHECK=$(echo "$RESULT" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print('\n'.join(d.get('files_to_check',[])[:5]))" 2>/dev/null)

        if [ -z "$FILES_TO_CHECK" ]; then
          echo "No files to check"
          echo "has_files=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "$FILES_TO_CHECK" > /tmp/files_to_check.txt
        echo "Files to check:"
        cat /tmp/files_to_check.txt
        echo "has_files=true" >> $GITHUB_OUTPUT

    - name: "Step 2: Generate suggestions"
      if: steps.find_files.outputs.has_files == 'true'
      id: suggestions
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        # Read target files
        echo "=== Target files ===" > /tmp/targets_content.txt
        while read -r file; do
          [[ ! "$file" =~ ^docs/ ]] && file="docs/$file"
          if [ -f "$file" ]; then
            echo "" >> /tmp/targets_content.txt
            echo "TARGET FILE: $file" >> /tmp/targets_content.txt
            echo "CONTENT (with line numbers):" >> /tmp/targets_content.txt
            head -500 "$file" | nl -ba >> /tmp/targets_content.txt
            echo "---END---" >> /tmp/targets_content.txt
          fi
        done < /tmp/files_to_check.txt

        # Build prompt
        echo 'You are a documentation editor. Integrate links to new docs. You have full freedom: add new sections, extend lists, modify sentences. Rules: match document style, use relative paths, do not duplicate links. Return JSON: {"suggestions": [{"target_file": "path", "operation": "replace or append", "line_number": N, "find": "exact text", "replace": "new text", "reason": "why"}]}' > /tmp/prompt2.txt
        echo "" >> /tmp/prompt2.txt
        echo "=== NEW FILES ===" >> /tmp/prompt2.txt
        cat /tmp/changed_info.txt >> /tmp/prompt2.txt
        cat /tmp/targets_content.txt >> /tmp/prompt2.txt

        # Debug: show prompt size
        echo "Prompt size: $(wc -c < /tmp/prompt2.txt) bytes"

        # Build JSON payload first
        echo "Building JSON payload..."
        if ! jq -n --rawfile prompt /tmp/prompt2.txt '{contents: [{parts: [{text: $prompt}]}], generationConfig: {responseMimeType: "application/json"}}' > /tmp/payload2.json 2>&1; then
          echo "jq failed to build payload:"
          cat /tmp/payload2.json
          exit 1
        fi
        echo "Payload size: $(wc -c < /tmp/payload2.json) bytes"

        # Call Gemini
        echo "Calling Gemini (Step 2)..."
        API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}"

        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/gemini_response2.json -X POST "$API_URL" -H "Content-Type: application/json" --data-binary @/tmp/payload2.json 2>&1 || echo "curl_failed")

        if [ "$HTTP_CODE" = "curl_failed" ]; then
          echo "curl command failed"
          exit 1
        fi

        echo "HTTP status: $HTTP_CODE"

        if [ "$HTTP_CODE" != "200" ]; then
          echo "Gemini API error:"
          cat /tmp/gemini_response2.json
          exit 1
        fi

        RESPONSE=$(cat /tmp/gemini_response2.json)
        SUGGESTIONS=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(d.get('candidates',[{}])[0].get('content',{}).get('parts',[{}])[0].get('text',''))" 2>/dev/null)

        if [ -z "$SUGGESTIONS" ] || [ "$SUGGESTIONS" = "null" ]; then
          echo "Error parsing Gemini response:"
          cat /tmp/gemini_response2.json | head -50
          exit 1
        fi

        echo "Step 2 result: $SUGGESTIONS"
        echo "$SUGGESTIONS" > /tmp/suggestions.json

        COUNT=$(echo "$SUGGESTIONS" | python3 -c "import sys,json; d=json.loads(sys.stdin.read(),strict=False); print(len(d.get('suggestions',[])))" 2>/dev/null || echo "0")
        if [ "$COUNT" = "0" ]; then
          echo "No suggestions"
          echo "has_suggestions=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "has_suggestions=true" >> $GITHUB_OUTPUT
        echo "Found $COUNT suggestions"

    - name: Apply suggestions
      if: steps.suggestions.outputs.has_suggestions == 'true'
      id: apply
      run: |
        # Write apply script
        base64 -d > /tmp/apply.py << 'B64'
        aW1wb3J0IGpzb24sIHJlLCBvcwp3aXRoIG9wZW4oJy90bXAvc3VnZ2VzdGlvbnMuanNvbicsICdyJykgYXMgZjoKICAgIGRhdGEgPSBqc29uLmxvYWRzKGYucmVhZCgpLCBzdHJpY3Q9RmFsc2UpCnN1Z2dlc3Rpb25zID0gZGF0YS5nZXQoJ3N1Z2dlc3Rpb25zJywgW10pCmlmIG5vdCBzdWdnZXN0aW9uczoKICAgIHByaW50KCdObyBzdWdnZXN0aW9ucycpCiAgICBleGl0KDApCnByaW50KGYnQXBwbHlpbmcge2xlbihzdWdnZXN0aW9ucyl9IHN1Z2dlc3Rpb25zLi4uJykKZGVmIG5vcm1hbGl6ZShzKToKICAgIHJldHVybiByZS5zdWIocidccysnLCAnICcsIHMuc3RyaXAoKSkKZm9yIHMgaW4gc3VnZ2VzdGlvbnM6CiAgICB0YXJnZXQgPSBzLmdldCgndGFyZ2V0X2ZpbGUnLCAnJykKICAgIG9wID0gcy5nZXQoJ29wZXJhdGlvbicsICcnKQogICAgZmluZCA9IHMuZ2V0KCdmaW5kJywgJycpCiAgICByZXBsYWNlID0gcy5nZXQoJ3JlcGxhY2UnLCAnJykKICAgIGxuID0gcy5nZXQoJ2xpbmVfbnVtYmVyJykKICAgIHByaW50KGYnLS0tIHt0YXJnZXR9ICh7b3B9KScpCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHModGFyZ2V0KToKICAgICAgICBwcmludCgnU0tJUDogbm90IGZvdW5kJykKICAgICAgICBjb250aW51ZQogICAgbGlua3MgPSByZS5maW5kYWxsKHInXF1cKChbXildK1wubWQpXCknLCByZXBsYWNlKQogICAgd2l0aCBvcGVuKHRhcmdldCwgJ3InKSBhcyBmOgogICAgICAgIGNvbnRlbnQgPSBmLnJlYWQoKQogICAgaWYgYW55KGwgaW4gY29udGVudCBmb3IgbCBpbiBsaW5rcyk6CiAgICAgICAgcHJpbnQoJ1NLSVA6IGxpbmsgZXhpc3RzJykKICAgICAgICBjb250aW51ZQogICAgaWYgb3AgPT0gJ2FwcGVuZCc6CiAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ2EnKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKHJlcGxhY2UgKyAnXG4nKQogICAgICAgIHByaW50KCdET05FOiBhcHBlbmRlZCcpCiAgICBlbGlmIG9wID09ICdyZXBsYWNlJzoKICAgICAgICBpZiBmaW5kIGFuZCBmaW5kIGluIGNvbnRlbnQ6CiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoZmluZCwgcmVwbGFjZSwgMSkKICAgICAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ3cnKSBhcyBmOgogICAgICAgICAgICAgICAgZi53cml0ZShjb250ZW50KQogICAgICAgICAgICBwcmludCgnRE9ORTogZXhhY3QgbWF0Y2gnKQogICAgICAgIGVsaWYgZmluZDoKICAgICAgICAgICAgbm9ybSA9IG5vcm1hbGl6ZShmaW5kKQogICAgICAgICAgICBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xuJykKICAgICAgICAgICAgZG9uZSA9IEZhbHNlCiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihsaW5lcykpOgogICAgICAgICAgICAgICAgZm9yIHcgaW4gcmFuZ2UoMSwgbWluKDYsIGxlbihsaW5lcyktaSsxKSk6CiAgICAgICAgICAgICAgICAgICAgaWYgbm9ybWFsaXplKCdcbicuam9pbihsaW5lc1tpOmkrd10pKSA9PSBub3JtOgogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4odGFyZ2V0LCAndycpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCdcbicuam9pbihsaW5lc1s6aV0gKyBbcmVwbGFjZV0gKyBsaW5lc1tpK3c6XSkpCiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50KGYnRE9ORTogZnV6enkgYXQgbGluZSB7aSsxfScpCiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBUcnVlCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBpZiBkb25lOgogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGlmIGRvbmU6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgIGlmIGxuOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZHggPSBpbnQobG4pIC0gMQogICAgICAgICAgICAgICAgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcbicpCiAgICAgICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihsaW5lcyk6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKHRhcmdldCwgJ3cnKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCdcbicuam9pbihsaW5lc1s6aWR4KzFdICsgW3JlcGxhY2VdICsgbGluZXNbaWR4KzE6XSkpCiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZidET05FOiBsaW5lIHtsbn0gZmFsbGJhY2snKQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICBwcmludCgnU0tJUDogbm90IGZvdW5kJyk=
        B64
        python3 /tmp/apply.py
        if git diff --quiet docs/; then
          echo "No changes made"
          echo "applied=false" >> $GITHUB_OUTPUT
        else
          echo "Changes applied"
          echo "applied=true" >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      if: steps.apply.outputs.applied == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        BRANCH="auto/cross-links-$(date +%Y%m%d-%H%M%S)"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git checkout -b "$BRANCH"
        git add docs/
        git commit -m "docs: add cross-links to related documentation"
        git push origin "$BRANCH"
        gh pr create --title "docs: add cross-links for recent changes" --body "Auto-generated cross-links. Please review." --head "$BRANCH" --base master
