# Database Overview
Aidbox uses PostgreSQL as its database engine, leveraging its robust JSONB capabilities, reliability, and performance for healthcare data storage.

## Storage model
All FHIR data is stored in PostgreSQL JSONb data format. It gives better performance and flexibility.

For each resource type Aidbox creates their own table:

```SQL
select * from Patient limit 1;
```

Result:

| Column         | Value                                                  |
|----------------|--------------------------------------------------------|
| resource_type  | Patient                                                |
| id             | 2193c2e7-4d66-74c6-17c5-6d0c1c094fc2                   |
| txid           | 178246                                                 |
| ts             | 2025-06-09T08:51:07.533413Z                            |
| cts            | 2025-06-09T08:51:07.533413Z                            |
| status         | created                                                |
| resource       | ``` {"gender": "male", "birthDate": "2025-01-01"} ```  |

Resource table contains `resource` column in JSONB format that stores FHIR resource data. And several additional columns for versioning, status, and other metadata.

See  [Database Schema](./database-schema.md) page for full details about Aidbox database schema.

## CRUD interactions

This table structure allows for simplified [CRUD operations](../api/rest-api/crud/README.md) on resources.

### Create

To create Patient resource you can use regular `insert` statement. You should specify 4 required columns:
- `id` - id of resource. It can be generated by `gen_random_uuid()` function or provided by client.
- `txid` - vesrion id. It can be generated by `nextval('transaction_id_seq')` - global Aidbox sequence, or provided by client.
- `status` - status of resource. It can be `created`, `updated`, `deleted`.
- `resource` - resource data in JSONB format.

```SQL
insert into Patient (
    id,
    txid,
    status,
    resource
) values (
    gen_random_uuid(),
    nextval('transaction_id_seq'),
    'created',
    '{"gender": "male", "birthDate": "2024-01-01"}'
)
```

### Read

To read FHIR data, it's enough to perform a select query on the target table
```SQL
select * from Patient limit 1;
```

You can query more FHIR like data structure by merging resource data with metadata `id` and `resource_type` columns:

```SQL
select jsonb_pretty(
    jsonb_build_object(
        'id', id,
        'resourceType', resource_type
    ) || resource
) as resource
from patient
limit 1
```

Result:
```json
{
    "id": "ad1eba27-815a-4421-a9fe-89da89b842d0",
    "gender": "male",
    "birthDate": "2024-01-01",
    "resourceType": "Patient"
}
```

### Update

On update, move previous version to history table

```SQL
update patient set resources = jsonb_set(resources, '{gender}', '"female"') where id = 'ID';
insert into patient_history select * from patient where id = 'ID';
```

### Delete

On delete move current version of resource into history table and add new row with deleted flag

```SQL
delete from patient where id = 'ID';
```

### History

To get full resource history select resource table and history table by id.

```SQL
select * from patient  where id = 'ID'
union all
select * from patient_history where id = 'ID'
```

See also [CRUD internals](./crud-internals.md).

## FHIR search SQL explained
Aidbox uses [PostgreSQL jsonb functions](https://www.postgresql.org/docs/current/functions-json.html) to retrieve fields to search for.
Depending on a type of [SearchParameter](../api/rest-api/fhir-search/README.md) (e.g. reference, token, string), the SQL differs.

Lets take a look how to several search types works in Aidbox.

### Reference
On the rest `GET /Observation?subject=Patient/123`

On the SQL

```SQL
select * from observation where jsonb_path_query_first(data, '$.subject.reference') = 'Patient/123'
```

### Token

On the rest `GET /Patient?identifier=ssn|123`

On the SQL

```SQL
select * from patient
where resource @> '{"identifier": [{"system": "ssn", "value": "123"}]}'
```

Aidbox uses `@>` operator to search for resources by token.

### String

Strings are more difficult. To search properly, by FHIR rules, we need to cast jsonb to text.

Lets see `GET /Patient?name=Smith`.

```sql
SELECT "patient".*
FROM "patient"
WHERE jsonb_path_query_array(
          "patient".resource,
          CAST('($.\"name\"[*]).** ? (@.type() == "string")' AS jsonpath))::text
      ) ILIKE unaccent('%"Smith%')
LIMIT 100
OFFSET 0;
```

## Advanced search
FHIR search cannot express everything.
Sometimes SQL is the only option to achieve complex performant enough search.
See [Aidbox Search](../api/rest-api/aidbox-search.md)

## Plains SQL access
It is absolutely fine to run plain SQL requests instead of using endpoints,
especially when FHIR does not provide a solution to the problem.
For example, updating some field in whole `patient` table using usual UPDATE.
```SQL
UPDATE patient SET ...
```
You can send plain SQL request in:
- [Aidbox UI](../overview/aidbox-ui/README.md)
- [psql](https://www.postgresql.org/docs/current/app-psql.html)
- any other SQL tools (Datagrip, PgAdmin)
- [$sql endpoint](../api/rest-api/other/sql-endpoints.md)

## Performance considerations
Performance can be improved by:
- Creating indexes
- Tuning PostgreSQL (workmem, shared buffers...)
- ...
toasts?

See more in the [Performance Considerations page](../deployment-and-maintenance/performance-considerations.md).

## SQL on FHIR
Most analytic and machine learning use cases require the preparation of FHIR data using
transformations and tabular projections from its original form.
Aidbox supports [SQL on FHIR specifiction](https://build.fhir.org/ig/FHIR/sql-on-fhir-v2/index.html).
Using ViewDefinition SQL on FHIR resource, you can flatten FHIR data and store as PostgreSQL view, materialized view or table.
See: [SQL on FHIR](../modules/sql-on-fhir/README.md).

## Transactional bulk & migrations
?

## Transactional isolation levels & conditional operations
By default, all requests in Aidbox are ran in `serializable` [isolation level](https://www.postgresql.org/docs/current/transaction-iso.html).
Using

## Requirements
See [Requirements](./requirements.md)

## Monitoring
Links to Maintenance page

## PostgreSQL Aidbox functions
See: [PostgreSQL functions](../../reference/todo-functions-page)




STRUCTURE
Database
  - Requirements
  - Database Schema & Storage Format
  - Query Resources & Search API SQL
  - Indexes & Performance
  - Transactional bulk & migrations
  - Transactional isolation levels & conditional operations
  - Database migrations: Which PostgreSQL user permissions is needed for migrations?
  - FAQ?
  - AidboxDB
    - Releases/versions
    - PostgreSQL Extensions
    - HA AidboxDB (CloudNativePGOperator/Crunchy)

reference:
  - Aidbox's functions
